<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Autosuggest</title>
    <script src="./js/github-corner.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/components/prism-core.min.js"></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.23.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <link rel="stylesheet" href="./css/main.css" />
    <link rel="stylesheet" href="./css/autocomplete.css" />
  </head>

  <body>
    <main class="container">
      <!-- menu start -->
      <aside>
        <h1 class="loupe">autocomplete</h1>
        <div class="shields">
          <img src="https://img.shields.io/github/package-json/v/tomik23/autosuggest" />
          <img src="https://img.shields.io/badge/License-MIT-green.svg" />
        </div>
        <div class="based"><a href="https://breakingbadapi.com/" target="_blank">BASED ON: The Breaking Bad API</a>
        </div>

        <ul class="menu">
          <li class="active"><a href="#started">Geting started</a></li>
          <li><a href="#basics">Basics example</a></li>
          <li><a href="#complex-example">Complex example</a></li>
          <li><a href="#no-results-example">No results</a></li>
          <li><a href="#static-file">Static file</a></li>
          <li><a href="#data-elements">Static file + data-elelemts</a></li>
          <li><a href="#groups">Data grouping</a></li>
          <li><a href="#local-data">Local data</a></li>
          <li><a href="#modal">Modal</a></li>
          <li><a href="#update-input-data">Update input field on selected items</a></li>
          <li><a href="#select-item">Select multiple values ver 1 <div><small>with count</small></div></a></li>
          <li><a href="#select-multiple-values">Select multiple values ver 2</a></li>
          <li><a href="#select-item-checkbox">Checkboxes</a></li>
          <li><a href="#address-geocoding">Address geocoding</a></li>
        </ul>
      </aside>
      <!-- menu end -->

      <div class="search-elements">
        <!-- Geting started start -->
        <article id="started" class="section">
          <div class="info-section">
            <h2>Gatting started</h2>
            <h3>Include JS and CSS files</h3>
            <p>The first thing you should do is download the <code><a
                href="https://github.com/tomik23/autocomplete/archive/master.zip">autocomplete</a></code>
              library files. All the necessary files are located in the
              "docs/js" and "docs/css" folders.
              If you want to make changes, the uncompiled javascript and sass files are in the sources folder.
            </p>
          </div>
          <div rel="HTML" class="html-class">
            <pre><code class="language-html">// CSS file
&lt;link rel=&quot;stylesheet&quot; href=&quot;path/to/autocomplete.css&quot;&gt;

// JS file
&lt;script src=&quot;path/to/autocomplete.min.js&quot;&gt;&lt;/script&gt;
</code></pre>
          </div>
          <p>If you want on older browsers - IE use polyfills</p>
          <div rel="HTML" class="html-class">
            <pre><code class="language-html">&lt;script&gt;
  if (!('Promise' in window)) {
    var script = document.createElement('script');
    script.src =
      'https://polyfill.io/v3/polyfill.min.js?features=Promise%2CElement.prototype.closest';
    document.getElementsByTagName('head')[0].appendChild(script);
  }
&lt;/script&gt;
</code></pre>
          </div>
          -- OR --
          <div rel="HTML" class="html-class">
            <pre><code class="language-html">&lt;script src=&quot;https://cdn.jsdelivr.net/npm/promise-polyfill@8/dist/polyfill.min.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://cdn.jsdelivr.net/npm/element-closest@3.0.2/browser.min.js&quot;&gt;&lt;/script&gt;</code></pre>
          </div>
          -- OR --
          <div rel="HTML" class="html-class">
            <pre><code class="language-html">&lt;script src=&quot;path/to/polyfill.js&quot;&gt;&lt;/script&gt;</code></pre>
          </div>
        </article>
        <!-- Geting started end -->

        <article>
          <div class="info-section">
            <h2>Configuration of the plugin:</h2>
            <h3>Settings</h3>

            <div class="table">
              <table class="first-table">
                <thead>
                  <tr>
                    <th>Property</th>
                    <th>Default</th>
                    <th>Required</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tr>
                  <td><code>element</code></td>
                  <td></td>
                  <td>&check;</td>
                  <td>Input field id</td>
                </tr>
                <tr>
                  <td><code>clearButton</code></td>
                  <td>false</td>
                  <td></td>
                  <td>A parameter set to 'true' adds a button to remove text from the input field. You can also use the
                    <code>destroy</code> method - description below
                  </td>
                </tr>
                <tr>
                  <td><code>selectFirst</code></td>
                  <td>false</td>
                  <td></td>
                  <td>Default selects the first item in the list of results</td>
                </tr>
                <tr>
                  <td><code>insertToInput</code></td>
                  <td>false</td>
                  <td></td>
                  <td>Adding an element selected with arrows to the input field field</td>
                </tr>
                <tr>
                  <td><code>disableCloseOnSelect</code></td>
                  <td>false</td>
                  <td></td>
                  <td>Prevents results from hiding after clicking on an item from the list</td>
                </tr>
                <tr>
                  <td><code>howManyCharacters</code></td>
                  <td>1</td>
                  <td></td>
                  <td>The number of characters entered should start searching</td>
                </tr>
                <tr>
                  <td><code>delay</code></td>
                  <td>500</td>
                  <td></td>
                  <td>Time in milliseconds that the component should wait after last keystroke before calling search
                    function 1000 = 1s</td>
                </tr>
                <tr>
                  <td><code>classGroup</code></td>
                  <td>""</td>
                  <td></td>
                  <td>Enter a class name, this class will be added to the group name elements</td>
                </tr>
              </table>
            </div>

            <div class="table">
              <table class="second-table">
                <thead>
                  <tr>
                    <th>Callbacks function</th>
                    <th>Required</th>
                    <th>Description</th>
                  </tr>
                </thead>
                <tr>
                  <td><code><b>onSearch</b>: ({ currentValue, element }) => {}</code></td>
                  <td>&check;</td>
                  <td>Function for user input. It can be a synchronous function or a promise</td>
                </tr>
                <tr>
                  <td><code><b>onResults</b>: ({ currentValue, matches, template, classGroup }) => {}</code></td>
                  <td>&check;</td>
                  <td>when we want to add the information 'No results found:' we need to do a comparison, check the
                    matches is 0 then set the template <code>return matches === 0 ? template : matches</code></td>
                </tr>
                <tr>
                  <td><code><b>onSubmit</b>: ({ index, element, object, results }) => {}</code></td>
                  <td></td>
                  <td>Executed on input submission</td>
                </tr>
                <tr>
                  <td><code><b>onOpened</b>: ({ type, element, results }) => {}</code></td>
                  <td></td>
                  <td>Returns two variables 'results' and 'showItems', 'resutls' first rendering of the results
                    'showItems' only showing the results when clicking on the input field</td>
                </tr>
                <tr>
                  <td><code><b>onSelectedItem</b>: ({ index, element, object }) => {}</code></td>
                  <td></td>
                  <td>Get index and data from li element after hovering over li with the mouse or using arrow keys ↓/↑
                  </td>
                </tr>
                <tr>
                  <td><code><b>onReset</b>: (element) => {}</code></td>
                  <td></td>
                  <td>After clicking the 'x' button</td>
                </tr>
                <tr>
                  <td><code><b>onClose</b>: () => {}</code></td>
                  <td></td>
                  <td>e.g. remove class after closing results. See an example of modal</td>
                </tr>
                <tr>
                  <td><code><b>noResults</b>: ({ element, currentValue, template }) => {}</code></td>
                  <td></td>
                  <td>Showing information: "no results"</td>
                </tr>
              </table>
            </div>

            <div class="table">
              <table>
                <thead>
                  <th>Public methods</th>
                  <th>Description</th>
                </thead>
                <tr>
                  <td><code><b>destroy</b></code></td>
                  <td>
                    Removes the autocomplete instance and its bindings,<br><span>how to use:</span>
                    <code>const auto = new Autocomplete('id', {});</code> <code><b>auto.destroy();</b></code>
                  </td>
                </tr>
              </table>
            </div>

            <br>
            <h2>Explanation of the variables</h2>
            <div class="table">
              <table>
                <thead>
                  <th>Function params</th>
                  <th>Description</th>
                </thead>
                <tr>
                  <td><code>index</code></td>
                  <td>Record number in the results</td>
                </tr>
                <tr>
                  <td><code>currentValue</code></td>
                  <td>Data entered into the input field</td>
                </tr>
                <tr>
                  <td><code>element</code></td>
                  <td>Input field for data entry</td>
                </tr>
                <tr>
                  <td><code>matches</code></td>
                  <td>An array of elements matching the entered word</td>
                </tr>
                <tr>
                  <td><code>object</code></td>
                  <td>Object from the query</td>
                </tr>
                <tr>
                  <td><code>type</code></td>
                  <td>Can return two results <code>results</code> or <code>showItems</code>.<br><code>results</code>
                    occurs
                    each time a
                    new result appears,
                    <code>showItems</code> occurs when we click on the input element and the result reappears
                  </td>
                </tr>
                <tr>
                  <td><code>results</code></td>
                  <td>The entire <code>ul + li</code> html element is returned</td>
                </tr>
                <tr>
                  <td><code>template</code></td>
                  <td>Create an element to display information about <code>no results</code></td>
                </tr>
              </table>
            </div>
        </article>

        <!-- Basic start -->
        <section id="basics" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Basic example</h2>
              <div class="sources">
                <a href="./js/examples/basic.js" target="_blank">source: basic</a>
              </div>
              <p>In fact, the input
                <code>&lt;input type="text" id="basic" placeholder="type w"&gt;</code>
                field is
                enough to add a
                search engine. The div surrounding the input field controls
                the appearance of this field and also the appearance of the <code>"loupe"</code> icons and the
                button with which we
                can clear the <code>"x"</code> field, as well as the possibility of an animation waiting for the
                results before our <code>REST API</code> returns us.
              </p>
            </div>
            <div class="auto-search">
              <input type="text" id="basic" placeholder="type w" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
              <code class="language-js">new Autocomplete('basic', {
  onSearch: ({ currentValue }) =&gt; {
    const api = `https://breakingbadapi.com/api/characters?name=${encodeURI(currentValue)}`;
    return new Promise((resolve) =&gt; {
      fetch(api)
        .then((response) =&gt; response.json())
        .then((data) =&gt; {
          resolve(data);
        })
        .catch((error) =&gt; {
          console.error(error);
        });
    });
  },

  onResults: ({ matches }) =&gt; {
    return matches
      .map(el =&gt; {
        return `
          &lt;li&gt;${el.name}&lt;/li&gt;`;
      }).join('');
  }
});</code>
            </pre>
            </div>
          </div>
        </section>
        <!-- Basic end -->

        <!-- Complex example start -->
        <section id="complex-example" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Complex example</h2>
              <div class="sources">
                <a href="./js/examples/complex.js" target="_blank">source: complex</a>
              </div>
              <p><code>search</code> - this class is responsible for the appearance of the input field</p>
              <p><code>max-height</code> - this class is responsible for the maximum height of the div in which the
                results appear, if there are many results, we can also scroll using the up/down arrows</p>
              <p><code>loupe</code> - this class shows a "loupe" icon that appears in the input field on
                the left</p>
            </div>
            <div class="wrap">
              <div class="auto-search max-height loupe">
                <input type="text" id="complex" autocomplete="off" placeholder="type w" aria-describedby="instruction"
                  aria-label="Search for a name" />
                <div id="instruction" class="hidden">
                  When autocomplete results are available use up and down arrows
                  to review and enter to select. Touch device users, explore by
                  touch or with swipe gestures.
                </div>
              </div>
              <button class="clear-button">clear<br><small>destroy() method</small></button>
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
              <code class="language-js">const auto = new Autocomplete('complex', {
  // search delay
  delay: 1000,

  // add button 'x' to clear the text from
  // the input filed
  clearButton: false,

  // default selects the first item in
  // the list of results
  selectFirst: true,

  // add text to the input field as you move through
  // the results with the up/down cursors
  insertToInput: true,

  // the number of characters entered
  // should start searching
  howManyCharacters: 1,

  // enter the name of the class by
  // which you will name the group element
  classGroup: 'group-by',

  // Function for user input. It can be a synchronous function or a promise
  // you can fetch data with jquery, axios, fetch, etc.
  onSearch: ({ currentValue }) => {
    // static file
    // const api = './characters.json';

    // OR -------------------------------

    // your REST API
    const api = `https://breakingbadapi.com/api/characters?name=${encodeURI(currentValue)}`;
    /**
      * jquery
      * If you want to use jquery you have to add the
      * jquery library to head html
      * https://cdnjs.com/libraries/jquery
      */
    // return $.ajax({
    //   url: api,
    //   method: 'GET',
    // })
    //   .done(function (data) {
    //     return data
    //   })
    //   .fail(function (xhr) {
    //     console.error(xhr);
    //   });

    // OR ----------------------------------

    /**
      * axios
      * If you want to use axios you have to add the
      * axios library to head html
      * https://cdnjs.com/libraries/axios
      */
    // return axios.get(api)
    //   .then((response) => {
    //     return response.data;
    //   })
    //   .catch(error => {
    //     console.log(error);
    //   });

    // OR ----------------------------------

    /**
      * Promise
      */
    return new Promise((resolve) => {
      fetch(api)
        .then((response) => response.json())
        .then((data) => {
          resolve(data);
        })
        .catch((error) => {
          console.error(error);
        });
    });
  },

  // this part is responsible for the number of records,
  // the appearance of li elements and it really depends
  // on you how it will look
  onResults: ({ currentValue, matches, template, classGroup, }) => {
    // const regex = new RegExp(^${input}`, 'gi'); // start with
    const regex = new RegExp(currentValue, 'gi');

    // counting status elements
    function count(status) {
      let count = {};
      matches.map(el => {
        count[el.status] = (count[el.status] || 0) + 1;
      });
      return `&lt;small&gt;${count[status]} items&lt;/small&gt;`;
    }

    // checking if we have results if we don't
    // take data from the noResults method
    return matches === 0 ? template : matches
      .sort((a, b) => a.status.localeCompare(b.status) || a.name.localeCompare(b.name))
      .map((el, index, array) => {
        // we create an element of the group
        let group = el.status !== array[index - 1]?.status
          ? `&lt;li class="${classGroup}"&gt;${el.status} ${count(el.status)}&lt;/li&gt;`
          : '';

        // this part is responsible for the appearance
        // in the drop-down list - see the example in index.html
        // remember only the first element from &lt;li&gt is put
        // into the input field, in this case the text
        // from the &lt;p&gt element
        return `
          ${group}
          &lt;li&gt;
            &lt;h2 style=&quot;margin-bottom: 10px;&quot;&gt;
              ${el.name.replace(regex, (str) =&gt; `&lt;b style=&quot;color: red;&quot;&gt;${str}&lt;/b&gt;`)}
            &lt;/h2&gt;
            &lt;div style=&quot;display: flex;&quot;&gt;
              &lt;div style=&quot;margin-right: 10px;&quot;&gt;
                &lt;img src=&quot;${el.img}&quot; style=&quot;max-width: 67px;max-height:95px&quot;&gt;
              &lt;/div&gt;
              &lt;div class=&quot;info&quot;&gt;
                &lt;h4&gt;${el.name}&lt;/h4&gt;
                &lt;div&gt;&lt;b&gt;nickname:&lt;/b&gt; - ${el.nickname}&lt;/div&gt;
                &lt;div&gt;&lt;b&gt;birthday:&lt;/b&gt; - ${el.birthday}&lt;/div&gt;
                &lt;div&gt;&lt;b&gt;status:&lt;/b&gt; - ${el.status}&lt;/div&gt;
              &lt;/div&gt;
            &lt;/div&gt;
          &lt;/li&gt;`;
      }).join('');
  },

  // the onSubmit function is executed when the user
  // submits their result by either selecting a result
  // from the list, or pressing enter or mouse button
  onSubmit: ({ index, element, object, results }) => {
    console.log('complex: ', index, element, object, results);
    // window.open(`https://www.imdb.com/find?q=${encodeURI(element.value)}`)
  },

  // get index and data from li element after
  // hovering over li with the mouse or using
  // arrow keys ↓ | ↑
  onSelectedItem: ({ index, element, object }) => {
    console.log('onSelectedItem:', index, element.value, object);
  },

  // the method presents no results
  noResults: ({ element, template }) => {
    template(`&lt;li&gt;No results found: &quot;${element.value}&quot;&lt;/li&gt;`);
  }
});

// use destroy() method
const clearButton = document.querySelector('.clear-button');
clearButton.addEventListener('click', () => {
  auto.destroy();
});

</code>
            </pre>
            </div>
          </div>
        </section>
        <!-- Complex example end -->

        <!-- No results start -->
        <section id="no-results-example" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>No results</h2>
              <div class="sources">
                <a href="./js/examples/no-results.js" target="_blank">source: no-results</a>
              </div>
              <p>Adding no result is a bit more complicated, so it is included in the examples. First, add the
                <code>noResults</code> method, then in the <code>onResults</code> method we check whether
                <code>maches</code> returns zero results, if so, it is enough to make a comparison of <code>return matches === 0 ? template :
                  matches</code>
              </p>
              <p>Now you just need to type in non-existent text, and <code>no results</code> will be displayed, only "no
                results" information.
              </p>
            </div>
            <div class="auto-search">
              <input type="text" id="no-results" placeholder="type xx" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
      <code class="language-js">new Autocomplete('no-results', {
  onSearch: ({ currentValue }) =&gt; {
    const api = './characters.json';
    return new Promise((resolve) =&gt; {
      fetch(api)
        .then((response) =&gt; response.json())
        .then((data) =&gt; {
          const result = data.sort((a, b) =&gt; a.name.localeCompare(b.name))
            .filter(element =&gt; {
              return element.name.match(new RegExp(currentValue, 'gi'))
            })
          resolve(result);
        })
        .catch((error) =&gt; {
          console.error(error);
        });
    });
  },

  onResults: ({ matches, template }) =&gt; {
    // checking if we have results if we don't
    // take data from the noResults method
    return matches === 0 ? template : matches
      .map(el =&gt; {
        return `
          &lt;li&gt;${el.name}&lt;/li&gt;`;
      }).join('');
  },

  noResults: ({ element, template }) =&gt; template(`&lt;li&gt;No results found: &quot;${element.value}&quot;&lt;/li&gt;`)
});</code>
    </pre>
            </div>
          </div>
        </section>
        <!-- No results end -->

        <!-- Static file start -->
        <section id="static-file" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Static file</h2>
              <div class="sources">
                <a href="./js/examples/static.js" target="_blank">source: static</a>
              </div>
              <p>Instead of the REST API, you can use a static files
                <code>const api='./characters.json'</code>Due to the fact that we
                download the entire json file locally, we should add sorting and filtering the results.
              </p>
              <p>We can add
                sorting and filtering in two ways. In the <code>onSearch</code> or <code>onResults</code>
                method.
              </p>
            </div>
            <div class="auto-search max-height loupe">
              <input type="text" id="static" aria-label="Search for a name" autocomplete="off" placeholder="type c" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
              <code class="language-js">new Autocomplete('static', {
  // onSearch
  onSearch: ({ currentValue }) =&gt; {
    // static file
    const api = './characters.json';

    return new Promise((resolve) =&gt; {
      fetch(api)
        .then((response) =&gt; response.json())
        .then((data) =&gt; {
          const result = data.sort((a, b) =&gt; a.name.localeCompare(b.name))
            .filter(element =&gt; {
              return element.name.match(new RegExp(currentValue, 'gi'))
            })
          resolve(result);
        })
        .catch((error) =&gt; {
          console.error(error);
        });
    });
  },

  onResults: ({ currentValue, matches }) =&gt; {
    return matches
      .map(el =&gt; {
        return `
          &lt;li class=&quot;loupe&quot;&gt;
            &lt;p&gt;${el.name.replace(new RegExp(currentValue, 'gi'), (str) =&gt; `&lt;b&gt;${str}&lt;/b&gt;`)}&lt;/p&gt;
          &lt;/li&gt;`;
      })
      .join('');
  }
});</code>
            </pre>
            </div>
          </div>
        </section>
        <!-- Static file end -->

        <!-- Static file + data-elements start -->
        <section id="data-elements" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Static file + data-elements</h2>
              <div class="sources">
                <a href="./js/examples/static-file-data.js" target="_blank">source: static-file-data</a>
              </div>
              <p>You want to download all the data, nothing easier. You can do it in the <code>onSubmit</code>
                method by clicking the mouse on the element, or by pressing enter when the element is selected, but also
                in the <code>onSelectedItem</code> method.</p>
              <p>That is, selecting an element, either with the mouse or
                by jumping on the elements with the arrows.</p>
              <p>Open the console and see what happens during these
                events.
              </p>
            </div>
            <div class="auto-search max-height loupe">
              <input type="text" id="static-file-data" aria-label="Search for a name" autocomplete="off"
                placeholder="type w" />
            </div>
            <div class="info-d"></div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
              <code class="language-js">new Autocomplete('static-file-data', {
  selectFirst: true,

  // onSearch
  onSearch: ({ currentValue }) =&gt; {
    // static file
    const api = './characters.json';

    return new Promise((resolve) =&gt; {
      fetch(api)
        .then((response) =&gt; response.json())
        .then((data) =&gt; {
          const result = data
            .sort((a, b) =&gt; a.name.localeCompare(b.name))
            .filter((element) =&gt; {
              return element.name.match(new RegExp(currentValue, 'gi'));
            });
          resolve(result);
        })
        .catch((error) =&gt; {
          console.error(error);
        });
    });
  },

  onResults: ({ currentValue, matches }) =&gt; {
    return matches.map(({ name, status }) =&gt; {
      return `
        &lt;li class=&quot;loupe&quot;&gt;
          &lt;p&gt;${name.replace(new RegExp(currentValue, 'gi'), (str) =&gt; `&lt;b&gt;${str}&lt;/b&gt;`)}&lt;/p&gt;
          &lt;small&gt;status - ${status}&lt;/small&gt;
        &lt;/li&gt;`;
    }).join('');
  },

  // event onsubmit
  onSubmit: ({ index, element, object }) =&gt; {
    const { name, status, img } = object;

    console.table('static-file-data', index, element, object);

    const template = `
      &lt;p&gt;name - ${name}&lt;/p&gt;
      &lt;p&gt;status - ${status}&lt;/p&gt;
      &lt;div class=&quot;image&quot;&gt;&lt;img src=&quot;${img}&quot;&gt;&lt;/div&gt;`;

    const info = document.querySelector('.info-d');
    info.classList.add('active-data');
    info.innerHTML = template;
  },

  // get index and data from li element after
  // hovering over li with the mouse
  onSelectedItem: ({ index, element, object }) =&gt; {
    console.log('onSelectedItem:', index, element.value, object);
  },

});</code>
            </pre>
            </div>
          </div>
        </section>
        <!-- Static file + data-elements end -->

        <!-- Group start -->
        <section id="groups" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Data grouping</h2>
              <div class="sources">
                <a href="./js/examples/group.js" target="_blank">source: group</a>
              </div>
              <p>First, we declare the class of group members <code>classGroup: 'group-by'</code></p>
              <p>Then we sort by our group, in our case it will be <code>status ['Alive', 'Deceased', 'Presumed
                  dead', 'Unknown']</code>,
                then we
                sort by
                <code>name</code>.
                Of course, it is not always needed, because we should get such soroting from our
                <code>api 'REST API'</code>
              </p>
              <p>
                The next thing is the <code>onResults</code> method which returns the third element of the group class
                name which
                will prevent moving between result records with the arrow and with the mouse.
                This class should be added to the group items.</p>
            </div>
            <div class="auto-search max-height loupe">
              <input type="text" id="group" placeholder="type w" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
      <code class="language-js">new Autocomplete('group', {
  // enter a class name, this class will
  // be added to the group name elements
  classGroup: 'group-by',

  onSearch: ({ currentValue }) =&gt; {
    const api = './characters.json';
    return new Promise((resolve) =&gt; {
      fetch(api)
        .then((response) =&gt; response.json())
        .then((data) =&gt; {

          // first, we sort by our group, in our case
          // it will be the status, then we sort by name
          // of course, it is not always necessary because
          // such soroting may be obtained from REST API
          const result = data
            .sort((a, b) =&gt; a.status.localeCompare(b.status) || a.name.localeCompare(b.name))
            .filter(element =&gt; {
              return element.name.match(new RegExp(currentValue, 'gi'))
            })
          resolve(result);
        })
        .catch((error) =&gt; {
          console.error(error);
        });
    });
  },

  onResults: ({ currentValue, matches, template, classGroup }) =&gt; {

    // counting status elements
    function count(status) {
      let count = {};
      matches.map(el =&gt; {
        count[el.status] = (count[el.status] || 0) + 1;
      });
      return `&lt;small&gt;${count[status]} items&lt;/small&gt;`;
    }

    return matches === 0 ? template : matches
      .map((el, index, array) =&gt; {

        // we create an element of the group
        let group = el.status !== array[index - 1]?.status
          ? `&lt;li class=&quot;${classGroup}&quot;&gt;${el.status} ${count(el.status)}&lt;/li&gt;`
          : '';

        return `
          ${group}
          &lt;li class=&quot;loupe&quot;&gt;
            &lt;p&gt;${el.name.replace(new RegExp(currentValue, 'gi'), (str) =&gt; `&lt;b&gt;${str}&lt;/b&gt;`)}&lt;/p&gt;
          &lt;/li&gt;`;
      }).join('');
  },

  noResults: ({ currentValue, template }) =&gt; template(`&lt;li&gt;No results found: &quot;${currentValue}&quot;&lt;/li&gt;`),
});</code>
    </pre>
            </div>
          </div>
        </section>
        <!-- Group end -->

        <!-- Local data start -->
        <section id="local-data" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Local data</h2>
              <div class="sources">
                <a href="./js/examples/local.js" target="_blank">source: local</a>
              </div>
              <p>Not only <code>json file</code> or <code>rest api</code>, but also data can be downloaded locally.
                Also
                in this case, you need to sort and filter the data.</p>
            </div>
            <div class="auto-search">
              <input type="text" id="local" placeholder="type w" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
      <code class="language-js">new Autocomplete('local', {
  onSearch: ({ currentValue }) =&gt; {

    // local data
    const data = [
      { &quot;name&quot;: &quot;Walter White&quot; },
      { &quot;name&quot;: &quot;Jesse Pinkman&quot; },
      { &quot;name&quot;: &quot;Skyler White&quot; },
      { &quot;name&quot;: &quot;Walter White Jr.&quot; }
    ];
    return data.sort((a, b) =&gt; a.name.localeCompare(b.name))
      .filter(element =&gt; {
        return element.name.match(new RegExp(currentValue, 'i'))
      })
  },

  onResults: ({ matches }) =&gt; {
    return matches
      .map(el =&gt; {
        return `
          &lt;li&gt;${el.name}&lt;/li&gt;`;
      }).join('');
  }
});</code>
    </pre>
            </div>
          </div>
        </section>
        <!-- Local data end -->

        <!-- Local data start -->
        <section id="modal" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Modal</h2>
              <div class="sources">
                <a href="./js/examples/modal.js" target="_blank">source: modal</a>
              </div>
              <p>To get this effect, add to html <code>&lt;div class=&quot;modal&quot;&gt;&lt;/div&gt;</code>
                preferably somewhere at the bottom of the page. For this we also need<code>onOpened</code> and
                <code>onClose</code>. Using the first function, we add a class that causes the modal to show up, and the
                second class removes the visibility of the modal.
              </p>
            </div>
            <div class="auto-search">
              <input type="text" id="modal-example" placeholder="type w" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
<code class="language-js">const modal = document.querySelector('.modal');

new Autocomplete('modal-example', {
  onSearch: ({ currentValue }) =&gt; {

    // local data
    const data = [
      { "name": "Walter White" },
      { "name": "Jesse Pinkman" },
      { "name": "Skyler White" },
      { "name": "Walter White Jr." }
    ];
    return data.sort((a, b) =&gt; a.name.localeCompare(b.name))
      .filter(element =&gt; {
        return element.name.match(new RegExp(currentValue, 'i'))
      })
  },

  onResults: ({ matches }) =&gt; {
    return matches
      .map(el =&gt; {
        return `
          &lt;li&gt;${el.name}&lt;/li&gt;`;
      }).join('');
  },

  // add 'active' class to modal div
  onOpened: () => {
    modal.classList.add('active');
  },

  // delete 'active' class from
  // modal if closing results
  onClose: () => {
    modal.classList.remove('active');
  }
});</code>
</pre>
            </div>
          </div>
        </section>
        <!-- Local data end -->

        <!-- update input start -->
        <section id="update-input-data" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Update input field on selected items</h2>
              <div class="sources">
                <a href="./js/examples/update-input.js" target="_blank">source: update-input</a>
              </div>
              <p>Adding this parameter adds the selected data to the input field while navigating through the records
                with the up/down arrows <code>insertToInput: true</code></p>
              <p>If you want to be able to add data to the input field after hovering the mouse over the record, you can
                do it using callback funciton
                <code>onSelectedItem: ({ element, object }) => {element.value = object.name}</code>
              </p>
            </div>
            <div class="auto-search">
              <input type="text" id="update-input" placeholder="type w" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <pre rel="js">
      <code class="language-js">new Autocomplete('update-input', {
  clearButton: true,

  insertToInput: true,

  onSearch: ({ currentValue }) =&gt; {
    // local data
    const data = [
      { "name": "Walter White" },
      { "name": "Jesse Pinkman" },
      { "name": "Skyler White" },
      { "name": "Walter White Jr." }
    ];
    return data.sort((a, b) =&gt; a.name.localeCompare(b.name))
      .filter(element =&gt; {
        return element.name.match(new RegExp(currentValue, 'i'))
      })
  },

  onResults: ({ matches }) =&gt; {
    return matches
      .map(el =&gt; {
        return `
          &lt;li&gt;${el.name}&lt;/li&gt;`;
      }).join('');
  },

  onSelectedItem: ({ element, object }) => {
    element.value = object.name
  }
});</code>
    </pre>
          </div>
        </section>
        <!-- update input end -->


        <!-- Local data start -->
        <section id="select-item" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Select multiple values ver 1</h2>
              <div class="sources">
                <a href="./js/examples/select.js" target="_blank">source: select</a>
              </div>
              <p>This example allows you to select multiple elements that are added below the input field. To remove all
                elements just click button clear 'x' or delete elements one by one by clicking the button 'x' which are
                next to the name of the taken elements.</p>
            </div>
            <div class="auto-search max-height count">
              <div class="count-number">0</div>
              <input type="text" id="select" placeholder="type w" />
            </div>
            <div class="selected-item"></div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
              <code class="language-js">let firstArray = [];
const countNumber = document.querySelector('.count-number');

new Autocomplete('select', {
  onSearch: ({ currentValue }) =&gt; {
    const api = './characters.json';
    return new Promise((resolve) =&gt; {
      fetch(api)
        .then((response) =&gt; response.json())
        .then((data) =&gt; {
          // first, we sort by our group, in our case
          // it will be the status, then we sort by name
          // of course, it is not always necessary because
          // such soroting may be obtained from REST API
          const result = data
            .sort((a, b) =&gt; a.name.localeCompare(b.name))
            .filter(element =&gt; {
              return element.name.match(new RegExp(currentValue, 'gi'))
            })
          resolve(result);
        })
        .catch((error) =&gt; {
          console.error(error);
        });
    });
  },

  onResults: ({ matches }) =&gt; {
    return matches
      .map(el =&gt; {
        return `
          &lt;li&gt;${el.name}&lt;/li&gt;`;
      }).join('');
  },

  onOpened: ({ results }) =&gt; {
    // if the elements from the 'array' are identical to those
    // from the rendered elements add the 'selected' class
    [].slice.call(results.children).map(item =&gt; {
      if (firstArray.includes(item.textContent)) {
        item.classList.add('selected');
      }
    });
  },

  onSubmit: ({ element, results }) =&gt; {
    if (firstArray.includes(element.value)) {
      return;
    };

    // add the selected item to the array
    firstArray.push(element.value);

    // the place where we will add selected elements
    const selectedItem = document.querySelector('.selected-item');

    // create elements with names and buttons
    const button = document.createElement('button');
    button.type = 'button'
    button.className = 'remove-item';
    button.insertAdjacentHTML('beforeend', '&lt;svg aria-label=&quot;Remove name&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;&lt;/svg&gt;');

    const item = document.createElement('div');
    item.className = 'item';

    // add each item in the array to the div selectedItem
    firstArray.map(itemText =&gt; {
      item.textContent = itemText;
      item.insertAdjacentElement('beforeend', button);
      selectedItem.appendChild(item);
    });

    function setAttributeType(type) {
      [].slice.call(results.children).map(item =&gt; {
        if (item.textContent === button.parentNode.textContent) {
          item.classList[type === 'remove' ? 'remove' : 'add']('selected')
        }
      });
    }

    // update number count
    countNumber.textContent = firstArray.length;

    // remove selected element
    button.addEventListener('click', (e) =&gt; {
      e.stopPropagation();
      const parentElement = button.parentNode;

      // remove element from array
      firstArray.splice(firstArray.indexOf(parentElement.textContent), 1);

      // remove disabled attr
      setAttributeType('remove');

      // update number count
      countNumber.textContent = firstArray.length;

      // remove element from div
      parentElement.parentNode.removeChild(parentElement);
    });

    // add disabled attr
    setAttributeType();
  },

  onReset: (element) =&gt; {
    const selectedItem = document.querySelector('.selected-item');
    selectedItem.innerHTML = '';
    // after clicking the 'x' button,
    // clear the table
    firstArray = [];

    // remove count number
    countNumber.textContent = 0;
  }
});</code>
            </pre>
            </div>
          </div>
        </section>
        <!-- Local data end -->

        <!-- Local data start -->
        <section id="select-multiple-values" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Select multiple values ver 2</h2>
              <div class="sources">
                <a href="./js/examples/multiple-values.js" target="_blank">source: multiple-values</a>
              </div>
              <p>This example allows you to select multiple elements that are added to the input field, to remove the
                selected fields, clear them by pressing the clear 'x' button or by removing the element or elements from
                the input field.</p>
            </div>
            <div class="auto-search max-height loupe">
              <input type="text" id="multiple-values" placeholder="type w" />
            </div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
              <code class="language-js">// array initialization
let secondArray = [];
new Autocomplete('multiple-values', {
  onSearch: ({ element }) => {
    // first get all the items and split with a comma
    const lastElement = element.value.split(',').pop().trim();
    // if the last item is 0 then we don't do a search
    if (lastElement.length === 0) return;

    const data = [
      { "name": "Grzesiek" },
      { "name": "Andrzej" },
      { "name": "Monika" },
      { "name": "Wiesława" },
      { "name": "Waldemar" },
      { "name": "Włodzimierz" },
      { "name": "Adam" },
      { "name": "Agnieszka" },
      { "name": "Paweł" },
      { "name": "Tadeusz" },
      { "name": "Tymoteusz" },
      { "name": "Łucja" },
      { "name": "Nela" }
    ];
    return data.sort((a, b) => a.name.localeCompare(b.name))
      .filter(element => {
        return element.name.match(new RegExp(lastElement, 'gi'))
      })
  },

  onResults: ({ matches }) => {
    return matches
      .map(el => {
        return `
          &lt;li&gt;${el.name}&lt;/li&gt;`;
      }).join('');
  },

  onOpened: ({ element, results }) => {
    // type - two values 'results' and 'showItems',
    // 'resutls' first rendering of the results
    // 'showItems' only showing the results when clicking on the input field
    // resultList all results rendered containing ul and li
    // input - root input

    // get the data from the input field and divide by the
    // decimal point, then remove the empty last element
    const currentValue = element.value.split(', ').splice(0, element.value.length - 1);

    // leave in the array only those elements that are in the input field
    secondArray = secondArray.filter(el => currentValue.includes(el));

    // check if the table 'secondArray' contains selected elements from 
    // the input field, if so we add the 'selected' class to the 'li' element,
    // if not, remove the 'selected' class from the li element
    [].slice.call(results.children).map(item => {
      item.classList[secondArray.includes(item.textContent) ? 'add' : 'remove']('selected')
    });

  },

  onSubmit: ({ index, element, object, results }) => {
    if (secondArray.includes(element.value)) {
      return;
    };

    console.log('index: ', index, 'object: ', object, 'results: ', results);

    // each click on the li element adds data to the array
    secondArray.push(element.value.trim());

    // check if the table includes selected items from
    // the list, if so, add the 'selected' class
    [].slice.call(results.children).map(item => {
      if (secondArray.includes(item.textContent)) {
        item.classList.add('selected');
      }
    });

    // add the elements from the array separated by commas
    // to the 'input' field, also add a comma to the last element
    element.value = `${secondArray.join(', ')}${secondArray > 2 ? secondArray.pop()[secondArray.length - 1] : ', '}`;

    // after selecting an item, set the
    // focus to the input field
    element.focus();
  },

  onReset: (element) => {
    // after clicking the 'x' button,
    // clear the table
    secondArray = [];
  }
});</code>
            </pre>
            </div>
          </div>
        </section>
        <!-- Local data end -->


        <!-- checkbox -->
        <section id="select-item-checkbox" class="section">
          <div class="search-element">
            <div class="info-section">
              <h2>Checkboxes</h2>
              <div class="sources">
                <a href="./js/examples/checkbox.js" target="_blank">source: checkbox</a>
              </div>
              <p>TThis example shows what you can use the <code>disableCloseOnSelect</code> variable - checkbox list.
              </p>
            </div>
            <div class="auto-search max-height count checkoxes">
              <div class="count-number-checkbox">0</div>
              <input type="text" id="checkbox" placeholder="write a programming language" />
            </div>
            <div class="selected-item-checkbox"></div>
          </div>
          <div rel="HTML" class="highlight html html-class"></div>
          <div rel="JS" class="highlight javascript html-class">
            <div>
              <pre>
              <code class="language-js">let checkbox = [];
const countNumberCheckbox = document.querySelector('.count-number-checkbox');

// the place where we will add selected elements
const selectedItem = document.querySelector('.selected-item-checkbox');

new Autocomplete('checkbox', {
  // prevents results from hiding after 
  // clicking on an item from the list
  disableCloseOnSelect: true,

  onSearch: ({ currentValue }) =&gt; {
    const api = './language.json';
    return new Promise((resolve) =&gt; {
      fetch(api)
        .then((response) =&gt; response.json())
        .then((data) =&gt; {
          // first, we sort by our group, in our case
          // it will be the status, then we sort by name
          // of course, it is not always necessary because
          // such soroting may be obtained from REST API
          const result = data
            .sort((a, b) =&gt; a.name.localeCompare(b.name))
            .filter(element =&gt; {
              return element.name.match(new RegExp(currentValue, 'gi'))
            })
          resolve(result);
        })
        .catch((error) =&gt; {
          console.error(error);
        });
    });
  },

  onResults: ({ matches }) =&gt; {
    return matches
      .map(el =&gt; {
        return `
            &lt;li class=&quot;custom-element&quot;&gt;
              &lt;label&gt;
                &lt;input type=&quot;checkbox&quot; value=&quot;${el.name}&quot;&gt;
                &lt;div class=&quot;checkbox&quot;&gt;${el.name}&lt;/div&gt;
              &lt;/label&gt;
            &lt;/li&gt;`;
      }).join('');
  },

  onOpened: ({ results }) =&gt; {
    // if the elements from the 'array' are identical to those
    // from the rendered elements add the 'selected' class

    [].slice.call(results.children).map((item, idx) =&gt; {
      const test = checkbox.some(element =&gt; element === item.textContent.trim());
      if (!test) return;

      let inputElement = results.children[idx].firstElementChild.children[0];
      inputElement.checked = true;
      inputElement.closest('.custom-element').classList.add('checkbox-selected');
    });
  },

  onSubmit: ({ index, element, object, results }) =&gt; {
    // update counter elements
    function countNumber(numb) {
      return countNumberCheckbox.textContent = numb;
    }

    // remove element from array
    function removeItemFromArray(el) {
      let index = checkbox.indexOf(el);
      if (index &gt; -1) {
        checkbox.splice(index, 1);
      }
    }

    function addRemoveClass(type) {
      inputElement.closest('.custom-element').classList[type]('checkbox-selected');
      // set false checbox
      inputElement.checked = type === 'remove' ? false : true;
    }

    let inputElement = results.children[index].firstElementChild.children[0];

    if (inputElement.checked) {
      // remove class 
      addRemoveClass('remove');

      // remove from array object
      removeItemFromArray(element.value);

      // update counter div
      countNumber(checkbox.length);

      // remove button
      [].slice.call(selectedItem.children).map(item =&gt; {
        if (item.textContent.trim() === element.value) {
          item.parentNode.removeChild(item);
        }
      })
      return;
    };

    // set checbox on true and add class
    addRemoveClass('add');

    // add the selected item to the array
    checkbox.push(element.value);

    // create elements with names and buttons
    const button = document.createElement('button');
    button.type = 'button'
    button.className = 'remove-item';
    button.insertAdjacentHTML('beforeend', '&lt;svg aria-label=&quot;Remove name&quot; height=&quot;16&quot; viewBox=&quot;0 0 16 16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M3.72 3.72a.75.75 0 011.06 0L8 6.94l3.22-3.22a.75.75 0 111.06 1.06L9.06 8l3.22 3.22a.75.75 0 11-1.06 1.06L8 9.06l-3.22 3.22a.75.75 0 01-1.06-1.06L6.94 8 3.72 4.78a.75.75 0 010-1.06z&quot;/&gt;&lt;/svg&gt;');

    const item = document.createElement('div');
    item.className = 'item';

    // add each item in the array to the div selectedItem
    checkbox.map(ele =&gt; {
      item.textContent = ele;
      item.insertAdjacentElement('beforeend', button);
      selectedItem.appendChild(item);
    });

    // update number count
    countNumber(checkbox.length);

    // remove selected element
    button.addEventListener('click', (e) =&gt; {
      e.preventDefault();

      const element = e.target.closest('.item');

      // remove from array object
      removeItemFromArray(element.textContent);

      // update checkbox
      [].slice.call(results.children).map((item, idx) =&gt; {
        let inputElement = results.children[idx].firstElementChild.children[0];
        inputElement.checked = false;
        addRemoveClass('remove');
      });

      // update number count
      countNumber(checkbox.length);

      // remove element from div
      const parentElement = button.parentNode;
      parentElement.parentNode.removeChild(parentElement);
    });
  },

  onReset: (element) =&gt; {
    selectedItem.innerHTML = '';
    // after clicking the 'x' button,
    // clear the table
    checkbox = [];

    // remove count number
    countNumberCheckbox.textContent = 0;
  },

  noResults: ({ element, template }) =&gt; template(`No results found: &quot;${element.value}&quot;`)
});
              </code>
            </pre>
            </div>
          </div>
        </section>
        <!-- checkbox end -->

        <!-- Other usage ideas start -->
        <article id="address-geocoding" class="section">
          <div class="info-section">
            <h2>Address geocoding</h2>
            <p>Below is an example of how to combine city geocoding with the <code>AUTOCOMPLETE</code> library. In
              fact, there are many ideas for using it ;)</p>
          </div>
          <iframe loading="lazy" class="iframe" src="https://tomik23.github.io/Leaflet.Autocomplete/"
            frameborder="0"></iframe>
        </article>
        <!-- Other usage ideas end -->

      </div>
      <button class="toggle-menu" arial-label="toogle menu" title="tootle menu"></button>
    </main>

    <div class="modal"></div>
    <script src="./js/autocomplete.min.js"></script>

    <script src="./js/examples/basic.js"></script>
    <script src="./js/examples/complex.js"></script>
    <script src="./js/examples/no-results.js"></script>
    <script src="./js/examples/static.js"></script>
    <script src="./js/examples/static-file-data.js"></script>
    <script src="./js/examples/group.js"></script>
    <script src="./js/examples/local.js"></script>
    <script src="./js/examples/modal.js"></script>
    <script src="./js/examples/update-input.js"></script>
    <script src="./js/examples/select.js"></script>
    <script src="./js/examples/multiple-values.js"></script>
    <script src="./js/examples/checkbox.js"></script>

  </body>

</html>